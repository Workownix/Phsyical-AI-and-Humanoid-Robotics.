---
title: 'Chapter 2: Nodes and Topics'
description: 'In-depth exploration of ROS 2 nodes and topics, the fundamental communication mechanisms for robot systems.'
keywords: ['ros2', 'nodes', 'topics', 'communication', 'publisher-subscriber']
sidebar_position: 2
sidebar_label: 'Chapter 2: Nodes and Topics'
learning_objectives: ['Understand ROS 2 node architecture and lifecycle', 'Implement publisher-subscriber communication patterns', 'Create and manage ROS 2 topics', 'Debug ROS 2 communication issues']
prerequisites: ['docs/module-1/chapter-1-intro-ros2']
estimated_time: 120
content_type: 'hands-on-lab'
difficulty: 'intermediate'
chapter_number: 2
---

# Chapter 2: Nodes and Topics

## Introduction to ROS 2 Architecture

ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software. It provides a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms.

The core concept in ROS 2 is a node - a process that performs computation. Nodes are organized into packages to make sharing code easier. Multiple nodes communicate with each other over a network using topics, services, actions, and parameters.

## Understanding Nodes

A node is an executable file within a ROS 2 package. Nodes are the fundamental building blocks of a ROS 2 application. They can receive, process, and publish data to other nodes.

### Creating a ROS 2 Node

Here's an example of a basic ROS 2 node:

```python
# simple_publisher.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):

    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Node Lifecycle

ROS 2 nodes have a well-defined lifecycle that includes:

1. **Unconfigured**: The node is created but not yet configured
2. **Inactive**: The node is configured but not active
3. **Active**: The node is running and performing its function
4. **Finalized**: The node is shut down

## Understanding Topics

Topics are named buses over which nodes exchange messages. They use a publisher-subscriber communication pattern where publishers push data to a topic and subscribers receive data from a topic.

### Topic Communication Pattern

The publisher-subscriber pattern has several characteristics:

- **Decoupling**: Publishers and subscribers don't need to know about each other
- **Asynchronous**: Publishers and subscribers can run at different rates
- **Broadcast**: Multiple subscribers can listen to a single publisher

### Creating a Subscriber Node

Here's an example of a subscriber node:

```python
# simple_subscriber.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):

    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Practical Example: Publisher-Subscriber Communication

Let's create a more practical example of a publisher-subscriber system that could be used in a robot:

```python
# robot_sensor_publisher.py
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
import random

class RobotSensorPublisher(Node):

    def __init__(self):
        super().__init__('robot_sensor_publisher')
        self.publisher_ = self.create_publisher(LaserScan, 'laser_scan', 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.publish_scan)
        
    def publish_scan(self):
        msg = LaserScan()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'laser_frame'
        
        # Simulate laser scan data
        msg.angle_min = -1.57  # -90 degrees
        msg.angle_max = 1.57   # 90 degrees
        msg.angle_increment = 0.01
        msg.time_increment = 0.0
        msg.scan_time = 0.1
        msg.range_min = 0.0
        msg.range_max = 10.0
        
        # Generate random ranges for this example
        num_readings = int((msg.angle_max - msg.angle_min) / msg.angle_increment)
        msg.ranges = [random.uniform(0.5, 5.0) for _ in range(num_readings)]
        
        self.publisher_.publish(msg)
        self.get_logger().info(f'Published laser scan with {len(msg.ranges)} readings')

def main(args=None):
    rclpy.init(args=args)
    node = RobotSensorPublisher()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Debugging ROS 2 Communication

When working with ROS 2 nodes and topics, debugging tools are essential:

```bash
# List all active topics
ros2 topic list

# Echo messages from a specific topic
ros2 topic echo /topic_name

# Get information about a topic
ros2 topic info /topic_name

# Publish a message to a topic from command line
ros2 topic pub --once /topic_name std_msgs/String "data: 'Hello World'"
```

## Diagrams

<!-- Placeholder for communication patterns diagram (e.g., publisher-subscriber graph, service call flow). -->

## Warning Boxes

:::tip Debugging ROS 2 Issues
-   Use `ros2 topic list`, `ros2 node list` to see active entities.
-   `ros2 topic echo <topic_name>` to inspect data flow.
-   `ros2 node info <node_name>` to get detailed information about a node.
-   `ros2 service list`, `ros2 service call <service_name> <arguments>` for services.
:::

## Summary

This chapter covered the fundamentals of nodes and topics in ROS 2. In the next chapter, we'll explore services, actions, and parameters that provide additional communication patterns for more complex robotic behaviors.