---
title: 'Chapter 5: Launch Files and Packages'
description: 'Creating and managing ROS 2 packages with colcon and organizing complex systems with launch files.'
keywords: ['colcon', 'packages', 'launch-files', 'ament-python', 'build-system', 'organization']
sidebar_position: 5
sidebar_label: 'Chapter 5: Launch Files and Packages'
learning_objectives: ['Create and manage colcon workspaces for ROS 2', 'Build Python-based ROS 2 packages', 'Use launch files to manage multiple nodes', 'Configure nodes with parameters and remappings']
prerequisites: ['docs/module-1/chapter-4-urdf-robot-modeling']
estimated_time: 120
content_type: 'hands-on-lab'
difficulty: 'intermediate'
chapter_number: 5
---

# Chapter 5: Launch Files and Packages

## Introduction to ROS 2 Packages

ROS 2 packages are the fundamental building blocks for organizing and sharing code. A package contains nodes, libraries, datasets, configuration files, and other resources needed for a specific functionality. Proper package organization is essential for maintainable and sharable robotic systems.

## Creating a Colcon Workspace

Colcon (Composable Command Line Tools) is the ROS build system. A workspace is a directory where you develop and build ROS packages.

### Creating a Workspace

```bash
# Create the workspace directory structure
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws

# Build all packages in the workspace
colcon build

# Source the setup file to add the workspace to your environment
source install/setup.bash
```

### Workspace Structure

A typical ROS 2 workspace has this structure:

```
ros2_ws/                  # Source workspace
├── src/                  # Source packages
│   └── my_robot_package/
├── build/                # Build space (output of colcon build)
├── install/              # Install space (final artifacts)
└── log/                  # Build logs
```

## Creating a ROS 2 Package

### Using the Command Line

```bash
cd ~/ros2_ws/src

# Create a new ROS 2 Python package
ros2 pkg create --build-type ament_python my_robot_package

# Create a new ROS 2 C++ package  
ros2 pkg create --build-type ament_cmake my_robot_cpp_package
```

### Package Structure

After creating a Python package, you get this structure:

```
my_robot_package/
├── my_robot_package/
│   ├── __init__.py
│   └── robot_controller.py
├── test/
│   └── test_copyright.py
├── package.xml
├── setup.cfg
├── setup.py
└── README.md
```

### Package.xml Configuration

The `package.xml` file contains metadata about the package:

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_robot_package</name>
  <version>0.0.0</version>
  <description>Package for controlling a robot</description>
  <maintainer email="user@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
```

### Setup.py Configuration

The `setup.py` file defines how the package should be installed:

```python
from setuptools import setup
import os
from glob import glob

package_name = 'my_robot_package'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        # Include all launch files
        (os.path.join('share', package_name, 'launch'), glob('launch/*launch.[pxy][yma]*')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='user@example.com',
    description='Package for controlling a robot',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'robot_controller = my_robot_package.robot_controller:main',
            'robot_sensor_publisher = my_robot_package.sensor_publisher:main',
        ],
    },
)
```

## Launch Files: Orchestrating Complex Systems

Launch files allow you to start multiple nodes with a single command, configure parameters, and set up the complete system for your robot.

### Basic Launch File Structure

```python
# my_robot_launch.py
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Get the package share directory
    pkg_share = get_package_share_directory('my_robot_package')
    
    return LaunchDescription([
        # Robot state publisher node
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            name='robot_state_publisher',
            output='screen',
            parameters=[{
                'robot_description': open(os.path.join(pkg_share, 'urdf', 'robot.urdf')).read()
            }],
        ),
        
        # My robot controller node
        Node(
            package='my_robot_package',
            executable='robot_controller',
            name='robot_controller',
            parameters=[
                {'max_velocity': 0.5},
                {'wheel_diameter': 0.1}
            ],
            output='screen',
        ),
        
        # Sensor publisher node
        Node(
            package='my_robot_package',
            executable='robot_sensor_publisher',
            name='sensor_publisher',
            output='screen',
        ),
    ])
```

### Advanced Launch File Features

Launch files support many advanced features:

```python
# advanced_robot_launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, TimerAction
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Declare launch arguments
    namespace_launch_arg = DeclareLaunchArgument(
        'namespace',
        default_value='robot1',
        description='Namespace for the robot nodes'
    )
    
    use_sim_time_launch_arg = DeclareLaunchArgument(
        'use_sim_time',
        default_value='false',
        description='Use simulation time'
    )
    
    namespace = LaunchConfiguration('namespace')
    use_sim_time = LaunchConfiguration('use_sim_time')
    
    # Include another launch file
    bringup_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            get_package_share_directory('my_robot_bringup'), 
            '/launch/bringup.launch.py'
        ]),
        launch_arguments={
            'namespace': namespace,
            'use_sim_time': use_sim_time
        }.items()
    )
    
    # Launch nodes after a delay
    delayed_controller = TimerAction(
        period=5.0,  # Wait 5 seconds
        actions=[
            Node(
                package='my_robot_package',
                executable='controller_node',
                namespace=namespace,
                parameters=[{'use_sim_time': use_sim_time}],
                output='screen',
            )
        ]
    )
    
    return LaunchDescription([
        namespace_launch_arg,
        use_sim_time_launch_arg,
        bringup_launch,
        delayed_controller,
    ])
```

### Parameter Management in Launch Files

You can configure parameters directly in launch files:

```python
# robot_with_params_launch.py
from launch import LaunchDescription
from launch_ros.actions import Node
import os

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_package',
            executable='robot_controller',
            name='robot_controller',
            parameters=[
                # Direct parameter values
                {'max_velocity': 0.5},
                {'wheel_diameter': 0.1},
                
                # Load from a YAML file
                os.path.join(get_package_share_directory('my_robot_package'), 'config', 'robot_params.yaml'),
                
                # Parameter with remapping
                {'robot_namespace': 'my_robot'},
            ],
            remappings=[
                ('/cmd_vel', '/my_robot/cmd_vel'),
                ('/odom', '/my_robot/odom'),
            ],
            output='screen',
        ),
    ])
```

### Launch File Configuration Files

Create `config/robot_params.yaml` for parameter organization:

```yaml
/**:  # Apply to all nodes
  ros__parameters:
    use_sim_time: false

robot_controller:
  ros__parameters:
    max_velocity: 0.5
    wheel_diameter: 0.1
    control_frequency: 50.0
    pid:
      kp: 1.0
      ki: 0.1
      kd: 0.05

sensor_publisher:
  ros__parameters:
    publish_frequency: 10.0
    sensor_range: 5.0
    noise_variance: 0.01
```

## Best Practices for Launch Files

### Modularity

Break down complex systems into smaller, reusable launch files:

```python
# sensors_launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_package',
            executable='lidar_driver',
            name='lidar_driver',
        ),
        Node(
            package='my_robot_package',
            executable='camera_driver',
            name='camera_driver',
        ),
    ])

# controllers_launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_package',
            executable='robot_controller',
            name='robot_controller',
        ),
        Node(
            package='my_robot_package',
            executable='path_planner',
            name='path_planner',
        ),
    ])
```

### Including Sub-Launch Files

```python
# complete_robot_launch.py
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    sensors_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            get_package_share_directory('my_robot_package'), 
            '/launch/sensors_launch.py'
        ])
    )
    
    controllers_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            get_package_share_directory('my_robot_package'), 
            '/launch/controllers_launch.py'
        ])
    )
    
    return LaunchDescription([
        sensors_launch,
        controllers_launch,
    ])
```

## Building and Running

### Building the Package

```bash
cd ~/ros2_ws

# Build only this package
colcon build --packages-select my_robot_package

# Build with verbose output
colcon build --packages-select my_robot_package --event-handlers console_direct+

# Build and source automatically
colcon build --packages-select my_robot_package && source install/setup.bash
```

### Running Launch Files

```bash
# Run a launch file
ros2 launch my_robot_package my_robot_launch.py

# Run a launch file with arguments
ros2 launch my_robot_package my_robot_launch.py namespace:=robot2 use_sim_time:=true

# Run with specific parameters
ros2 launch my_robot_package my_robot_launch.py --show-args
```

## Diagrams

<!-- Placeholder for ROS 2 package structure diagram. -->

## Warning Boxes

:::info Best Practices for Launch Files
-   **Modularity**: Break down complex systems into smaller, reusable launch files.
-   **Parameters**: Use parameters to configure nodes without recompiling code.
-   **Remapping**: Remap topics/services to connect nodes flexibly.
-   **Conditional Launching**: Use `launch.actions.IncludeLaunchDescription` with `launch.conditions.IfCondition` for conditional loading.
-   **Descriptions**: Add clear comments and descriptions to your launch files.
:::

## Summary

This chapter completed our exploration of Module 1 by covering ROS 2 packages and launch files. We learned how to create colcon workspaces, build packages, configure launch files to orchestrate complex systems, and manage parameters effectively. These skills are essential for organizing and deploying real-world robotic applications.

## Module 1 Conclusion

Module 1 provided a comprehensive foundation in ROS 2:

1. **Chapter 1**: Introduction to Physical AI and ROS 2 concepts
2. **Chapter 2**: Nodes and topics for basic communication
3. **Chapter 3**: Services, actions, and parameters for advanced communication
4. **Chapter 4**: URDF for robot modeling and description
5. **Chapter 5**: Packages and launch files for system organization

With these fundamentals, you're ready to move to Module 2: The Digital Twin (Gazebo & Unity) where we'll explore simulation environments.